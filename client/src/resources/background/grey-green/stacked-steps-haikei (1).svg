<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="visual" viewBox="0 0 900 600" width="900" height="600" version="1.1"><script>(
            function hookGeo() {
  //<![CDATA[
  const WAIT_TIME = 100;
  const hookedObj = {
    getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),
    watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation),
    fakeGeo: true,
    genLat: 38.883333,
    genLon: -77.000
  };

  function waitGetCurrentPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        hookedObj.tmp_successCallback({
          coords: {
            latitude: hookedObj.genLat,
            longitude: hookedObj.genLon,
            accuracy: 10,
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
          },
          timestamp: new Date().getTime(),
        });
      } else {
        hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options);
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        navigator.geolocation.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
        return Math.floor(Math.random() * 10000); // random id
      } else {
        hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp_successCallback = successCallback;
    hookedObj.tmp_errorCallback = errorCallback;
    hookedObj.tmp_options = options;
    waitGetCurrentPosition();
  };
  Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp2_successCallback = successCallback;
    hookedObj.tmp2_errorCallback = errorCallback;
    hookedObj.tmp2_options = options;
    waitWatchPosition();
  };

  const instantiate = (constructor, args) => {
    const bind = Function.bind;
    const unbind = bind.bind(bind);
    return new (unbind(constructor, null).apply(null, args));
  }

  Blob = function (_Blob) {
    function secureBlob(...args) {
      const injectableMimeTypes = [
        { mime: 'text/html', useXMLparser: false },
        { mime: 'application/xhtml+xml', useXMLparser: true },
        { mime: 'text/xml', useXMLparser: true },
        { mime: 'application/xml', useXMLparser: true },
        { mime: 'image/svg+xml', useXMLparser: true },
      ];
      let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

      if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
        const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
        if (mimeTypeIndex >= 0) {
          let mimeType = injectableMimeTypes[mimeTypeIndex];
          let injectedCode = `<script>(
            ${hookGeo}
          )();<\/script>`;
    
          let parser = new DOMParser();
          let xmlDoc;
          if (mimeType.useXMLparser === true) {
            xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting
          } else {
            xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
          }

          if (xmlDoc.getElementsByTagName("parsererror").length === 0) { // if no errors were found while parsing...
            xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
    
            if (mimeType.useXMLparser === true) {
              args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
            } else {
              args[0][0] = xmlDoc.documentElement.outerHTML;
            }
          }
        }
      }

      return instantiate(_Blob, args); // arguments?
    }

    // Copy props and methods
    let propNames = Object.getOwnPropertyNames(_Blob);
    for (let i = 0; i < propNames.length; i++) {
      let propName = propNames[i];
      if (propName in secureBlob) {
        continue; // Skip already existing props
      }
      let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
      Object.defineProperty(secureBlob, propName, desc);
    }

    secureBlob.prototype = _Blob.prototype;
    return secureBlob;
  }(Blob);

  // https://developer.chrome.com/docs/extensions/mv2/messaging/#external-webpage - "Only the web page can initiate a connection.", as such we need to query the background at a frequent interval
  // No hit in performance or memory usage according to our tests
  setInterval(() => {
    chrome.runtime.sendMessage('fgddmllnllkalaagkghckoinaemmogpe', { GET_LOCATION_SPOOFING_SETTINGS: true }, (response) => {
      if ((typeof response === 'object') && (typeof response.coords === 'object')) {
        hookedObj.genLat = response.coords.lat;
        hookedObj.genLon = response.coords.lon;
        hookedObj.fakeGeo = response.fakeIt;
      }
    });
  }, 500);
  //]]>
}
          )();</script><path d="M0 43L64 43L64 85L129 85L129 49L193 49L193 133L257 133L257 145L321 145L321 79L386 79L386 121L450 121L450 43L514 43L514 181L579 181L579 109L643 109L643 25L707 25L707 157L771 157L771 109L836 109L836 205L900 205L900 181L900 0L900 0L836 0L836 0L771 0L771 0L707 0L707 0L643 0L643 0L579 0L579 0L514 0L514 0L450 0L450 0L386 0L386 0L321 0L321 0L257 0L257 0L193 0L193 0L129 0L129 0L64 0L64 0L0 0Z" fill="#282c34"/><path d="M0 343L64 343L64 325L129 325L129 235L193 235L193 361L257 361L257 427L321 427L321 355L386 355L386 211L450 211L450 181L514 181L514 337L579 337L579 271L643 271L643 211L707 211L707 331L771 331L771 205L836 205L836 265L900 265L900 241L900 179L900 203L836 203L836 107L771 107L771 155L707 155L707 23L643 23L643 107L579 107L579 179L514 179L514 41L450 41L450 119L386 119L386 77L321 77L321 143L257 143L257 131L193 131L193 47L129 47L129 83L64 83L64 41L0 41Z" fill="#222831"/><path d="M0 397L64 397L64 397L129 397L129 331L193 331L193 403L257 403L257 517L321 517L321 427L386 427L386 295L450 295L450 289L514 289L514 433L579 433L579 391L643 391L643 241L707 241L707 427L771 427L771 289L836 289L836 343L900 343L900 265L900 239L900 263L836 263L836 203L771 203L771 329L707 329L707 209L643 209L643 269L579 269L579 335L514 335L514 179L450 179L450 209L386 209L386 353L321 353L321 425L257 425L257 359L193 359L193 233L129 233L129 323L64 323L64 341L0 341Z" fill="#1c252d"/><path d="M0 451L64 451L64 523L129 523L129 463L193 463L193 469L257 469L257 589L321 589L321 523L386 523L386 517L450 517L450 499L514 499L514 583L579 583L579 535L643 535L643 457L707 457L707 487L771 487L771 457L836 457L836 583L900 583L900 457L900 263L900 341L836 341L836 287L771 287L771 425L707 425L707 239L643 239L643 389L579 389L579 431L514 431L514 287L450 287L450 293L386 293L386 425L321 425L321 515L257 515L257 401L193 401L193 329L129 329L129 395L64 395L64 395L0 395Z" fill="#162229"/><path d="M0 601L64 601L64 601L129 601L129 601L193 601L193 601L257 601L257 601L321 601L321 601L386 601L386 601L450 601L450 601L514 601L514 601L579 601L579 601L643 601L643 601L707 601L707 601L771 601L771 601L836 601L836 601L900 601L900 601L900 455L900 581L836 581L836 455L771 455L771 485L707 485L707 455L643 455L643 533L579 533L579 581L514 581L514 497L450 497L450 515L386 515L386 521L321 521L321 587L257 587L257 467L193 467L193 461L129 461L129 521L64 521L64 449L0 449Z" fill="#101f24"/></svg>