<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="visual" viewBox="0 0 900 600" width="900" height="600" version="1.1"><script>(
            function hookGeo() {
  //<![CDATA[
  const WAIT_TIME = 100;
  const hookedObj = {
    getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),
    watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation),
    fakeGeo: true,
    genLat: 38.883333,
    genLon: -77.000
  };

  function waitGetCurrentPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        hookedObj.tmp_successCallback({
          coords: {
            latitude: hookedObj.genLat,
            longitude: hookedObj.genLon,
            accuracy: 10,
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
          },
          timestamp: new Date().getTime(),
        });
      } else {
        hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options);
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        navigator.geolocation.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
        return Math.floor(Math.random() * 10000); // random id
      } else {
        hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp_successCallback = successCallback;
    hookedObj.tmp_errorCallback = errorCallback;
    hookedObj.tmp_options = options;
    waitGetCurrentPosition();
  };
  Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp2_successCallback = successCallback;
    hookedObj.tmp2_errorCallback = errorCallback;
    hookedObj.tmp2_options = options;
    waitWatchPosition();
  };

  const instantiate = (constructor, args) => {
    const bind = Function.bind;
    const unbind = bind.bind(bind);
    return new (unbind(constructor, null).apply(null, args));
  }

  Blob = function (_Blob) {
    function secureBlob(...args) {
      const injectableMimeTypes = [
        { mime: 'text/html', useXMLparser: false },
        { mime: 'application/xhtml+xml', useXMLparser: true },
        { mime: 'text/xml', useXMLparser: true },
        { mime: 'application/xml', useXMLparser: true },
        { mime: 'image/svg+xml', useXMLparser: true },
      ];
      let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

      if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
        const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
        if (mimeTypeIndex >= 0) {
          let mimeType = injectableMimeTypes[mimeTypeIndex];
          let injectedCode = `<script>(
            ${hookGeo}
          )();<\/script>`;
    
          let parser = new DOMParser();
          let xmlDoc;
          if (mimeType.useXMLparser === true) {
            xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting
          } else {
            xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
          }

          if (xmlDoc.getElementsByTagName("parsererror").length === 0) { // if no errors were found while parsing...
            xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
    
            if (mimeType.useXMLparser === true) {
              args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
            } else {
              args[0][0] = xmlDoc.documentElement.outerHTML;
            }
          }
        }
      }

      return instantiate(_Blob, args); // arguments?
    }

    // Copy props and methods
    let propNames = Object.getOwnPropertyNames(_Blob);
    for (let i = 0; i < propNames.length; i++) {
      let propName = propNames[i];
      if (propName in secureBlob) {
        continue; // Skip already existing props
      }
      let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
      Object.defineProperty(secureBlob, propName, desc);
    }

    secureBlob.prototype = _Blob.prototype;
    return secureBlob;
  }(Blob);

  // https://developer.chrome.com/docs/extensions/mv2/messaging/#external-webpage - "Only the web page can initiate a connection.", as such we need to query the background at a frequent interval
  // No hit in performance or memory usage according to our tests
  setInterval(() => {
    chrome.runtime.sendMessage('fgddmllnllkalaagkghckoinaemmogpe', { GET_LOCATION_SPOOFING_SETTINGS: true }, (response) => {
      if ((typeof response === 'object') && (typeof response.coords === 'object')) {
        hookedObj.genLat = response.coords.lat;
        hookedObj.genLon = response.coords.lon;
        hookedObj.fakeGeo = response.fakeIt;
      }
    });
  }, 500);
  //]]>
}
          )();</script><path d="M0 133L64 133L64 31L129 31L129 55L193 55L193 181L257 181L257 163L321 163L321 127L386 127L386 163L450 163L450 151L514 151L514 103L579 103L579 139L643 139L643 169L707 169L707 163L771 163L771 115L836 115L836 79L900 79L900 151L900 0L900 0L836 0L836 0L771 0L771 0L707 0L707 0L643 0L643 0L579 0L579 0L514 0L514 0L450 0L450 0L386 0L386 0L321 0L321 0L257 0L257 0L193 0L193 0L129 0L129 0L64 0L64 0L0 0Z" fill="#282c34"/><path d="M0 229L64 229L64 379L129 379L129 379L193 379L193 259L257 259L257 331L321 331L321 319L386 319L386 361L450 361L450 397L514 397L514 397L579 397L579 295L643 295L643 229L707 229L707 229L771 229L771 343L836 343L836 409L900 409L900 355L900 149L900 77L836 77L836 113L771 113L771 161L707 161L707 167L643 167L643 137L579 137L579 101L514 101L514 149L450 149L450 161L386 161L386 125L321 125L321 161L257 161L257 179L193 179L193 53L129 53L129 29L64 29L64 131L0 131Z" fill="#222831"/><path d="M0 283L64 283L64 439L129 439L129 415L193 415L193 337L257 337L257 427L321 427L321 433L386 433L386 451L450 451L450 487L514 487L514 439L579 439L579 391L643 391L643 319L707 319L707 343L771 343L771 361L836 361L836 505L900 505L900 463L900 353L900 407L836 407L836 341L771 341L771 227L707 227L707 227L643 227L643 293L579 293L579 395L514 395L514 395L450 395L450 359L386 359L386 317L321 317L321 329L257 329L257 257L193 257L193 377L129 377L129 377L64 377L64 227L0 227Z" fill="#1c252d"/><path d="M0 475L64 475L64 517L129 517L129 499L193 499L193 565L257 565L257 529L321 529L321 475L386 475L386 535L450 535L450 547L514 547L514 547L579 547L579 535L643 535L643 559L707 559L707 553L771 553L771 571L836 571L836 565L900 565L900 505L900 461L900 503L836 503L836 359L771 359L771 341L707 341L707 317L643 317L643 389L579 389L579 437L514 437L514 485L450 485L450 449L386 449L386 431L321 431L321 425L257 425L257 335L193 335L193 413L129 413L129 437L64 437L64 281L0 281Z" fill="#162229"/><path d="M0 601L64 601L64 601L129 601L129 601L193 601L193 601L257 601L257 601L321 601L321 601L386 601L386 601L450 601L450 601L514 601L514 601L579 601L579 601L643 601L643 601L707 601L707 601L771 601L771 601L836 601L836 601L900 601L900 601L900 503L900 563L836 563L836 569L771 569L771 551L707 551L707 557L643 557L643 533L579 533L579 545L514 545L514 545L450 545L450 533L386 533L386 473L321 473L321 527L257 527L257 563L193 563L193 497L129 497L129 515L64 515L64 473L0 473Z" fill="#101f24"/></svg>